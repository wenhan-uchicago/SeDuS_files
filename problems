Oct 9, 2015

something wrong with sample[2*N]; and sample[] is initialized by SamplingIndividuals(). and many wired sampleXXX just pops out of NOWHERE. going to do trouble-shooting tomorrow. had to sleep.

Oct 9, 2015, again

previous problem was caused by mistakes on having SAMPLE > N, fixed;
however, float * SiteFrequencySpectrumPrint() seems to return a *local* array; maybe this is causing problem?

Oct 10, 2015

Still not figured out why this happens when N = 10, SAMPLE = 5, PROMETHEUS = 10; however, everything works well when N = 100, SAMPLE = 50
Just have no idea at all

================

Wired thing is, it happens sometimes, but not always... wired..

Oct 10, 2015

The problem with DivergenceForAll(), should be caused by a single mutation saved multiple times in mutation[block][k], so that mutation[block][i] == mutation[block][i+1] etc. I think.

================

Before modifying DupliFreq(), dup_1 will be 0 for SFS; this is due to SiteFrequencySpectrumPrint() will return 0 if... After modifying that, seems to be working. BUT, definately need to spend more time on SiteFrequencySpectrumPrint().

Oct 11, 2015

DupliFreq()'s problem is caused by dup_2 (i.e. block 4) having 2 consecutive same mutation positions in pointer[][]->mutation[block][k], meaning pointer[][]->mutation[block][k] == pointer[][]->mutation[block][k+1]. trying to figure out why

================

Probably due to forgetting adding mutational information into block 0 and block 2, in void mutation() when block == 4

Oct 12, 2015

Because in phaseVI(), a father of #block = 4 could become #block = 5, which does not happen in phaseII(). and this causes the lose_of_duplicontent[] useless

================

Because I am using (1 + rand() % (2 * N - 1)) for generating the number of chroms carrying not dup_1 for next generation, therefore, maybe the 1st generation has 1 chrom without dup_1, the next may have 199 chroms carrying no dup_1. this should be the causes of the huge drop of divergence rate

================

It seems that SiteFrequencySpectrumPrint_for_phaseVI()'s return results, are still causing troubles. maybe write it without a whole-scope float results[]? Maybe consider using a reference?

================

THOUGH, wiredly enough, it seems to be fine in the odd server... maybe Code::Blocks sucks??

================

in line 2963, it seems that all blocks (including single-copy block) are sharing a same multihit vector, which to me seems wrong. single-copy block should have its own multihit vector??? (given that --

    if (muttable[m].frequency == 0 && muttable[m].block == 1) {
       multihid[muttable[m].position] = false;
    }

will need to inspect more carefully later

Oct 13

Found redundent positions in muttable[].block == 4, in phaseIV(). I suspect this is caused by duplication_2(), where all information from ori and dup_1 are copied, making this to be copied twice?

But the muttable[].block == 0 seems to be fine, no redudent positions at all.. This doesn't make sense if in FSL(), all information is mutually copied to each other..

I SEE!! Because in FSL(), the information will be copied once to block 0. For example, in there is muttable[10].block = 4, muttable[10].position = 1000; and muttable[11].block = 4, muttable[11].position = 1000, which is redundent. Then, this information is only copied to block 0 when it is in block 0's for loop; this will not be copied to block 0 in block 4's for loop. And as block 0 initially does not have redundency, this will only be copied once!!! (same is true for block 2, no redundency at the beginning means no redundency always!!)

================

This is correct!! After changing duplication_2(), this redundency is eliminated in muttable[].block == 4!!