Oct 9, 2015

something wrong with sample[2*N]; and sample[] is initialized by SamplingIndividuals(). and many wired sampleXXX just pops out of NOWHERE. going to do trouble-shooting tomorrow. had to sleep.

Oct 9, 2015, again

previous problem was caused by mistakes on having SAMPLE > N, fixed;
however, float * SiteFrequencySpectrumPrint() seems to return a *local* array; maybe this is causing problem?

Oct 10, 2015

Still not figured out why this happens when N = 10, SAMPLE = 5, PROMETHEUS = 10; however, everything works well when N = 100, SAMPLE = 50
Just have no idea at all

================

Wired thing is, it happens sometimes, but not always... wired..

Oct 10, 2015

The problem with DivergenceForAll(), should be caused by a single mutation saved multiple times in mutation[block][k], so that mutation[block][i] == mutation[block][i+1] etc. I think.

================

Before modifying DupliFreq(), dup_1 will be 0 for SFS; this is due to SiteFrequencySpectrumPrint() will return 0 if... After modifying that, seems to be working. BUT, definately need to spend more time on SiteFrequencySpectrumPrint().

Oct 11, 2015

DupliFreq()'s problem is caused by dup_2 (i.e. block 4) having 2 consecutive same mutation positions in pointer[][]->mutation[block][k], meaning pointer[][]->mutation[block][k] == pointer[][]->mutation[block][k+1]. trying to figure out why

================

Probably due to forgetting adding mutational information into block 0 and block 2, in void mutation() when block == 4

Oct 12, 2015

Because in phaseVI(), a father of #block = 4 could become #block = 5, which does not happen in phaseII(). and this causes the lose_of_duplicontent[] useless

================

Because I am using (1 + rand() % (2 * N - 1)) for generating the number of chroms carrying not dup_1 for next generation, therefore, maybe the 1st generation has 1 chrom without dup_1, the next may have 199 chroms carrying no dup_1. this should be the causes of the huge drop of divergence rate

================

It seems that SiteFrequencySpectrumPrint_for_phaseVI()'s return results, are still causing troubles. maybe write it without a whole-scope float results[]? Maybe consider using a reference?

================

THOUGH, wiredly enough, it seems to be fine in the odd server... maybe Code::Blocks sucks??

================

in line 2963, it seems that all blocks (including single-copy block) are sharing a same multihit vector, which to me seems wrong. single-copy block should have its own multihit vector??? (given that --

    if (muttable[m].frequency == 0 && muttable[m].block == 1) {
       multihid[muttable[m].position] = false;
    }

will need to inspect more carefully later

Oct 13

Found redundent positions in muttable[].block == 4, in phaseIV(). I suspect this is caused by duplication_2(), where all information from ori and dup_1 are copied, making this to be copied twice?

But the muttable[].block == 0 seems to be fine, no redudent positions at all.. This doesn't make sense if in FSL(), all information is mutually copied to each other..

I SEE!! Because in FSL(), the information will be copied once to block 0. For example, in there is muttable[10].block = 4, muttable[10].position = 1000; and muttable[11].block = 4, muttable[11].position = 1000, which is redundent. Then, this information is only copied to block 0 when it is in block 0's for loop; this will not be copied to block 0 in block 4's for loop. And as block 0 initially does not have redundency, this will only be copied once!!! (same is true for block 2, no redundency at the beginning means no redundency always!!)

================

This is correct!! After changing duplication_2(), this redundency is eliminated in muttable[].block == 4!!

================

Also, the information in mpb[4] was not properly set to 0 for child produced by a father without block 5; so the pointer[][].mpb[4] remains the same as previous generation!!!! (which means its previous generation could be > 0, causing a problem) (but, is this a problem for phaseII() too??)

================

(WRONG) Because the information for block 2 in phaseII() comes from the father, it is actually copied. So long as the initial father mpb[2] == 0, the same will be true for the son!! But I may forgot copy the information about father's mpb[4] when father->b == 3 (i.e., father does not carry dup_2)
(NOOOOOO!!!! It actually is not copied; and I've tested, some do have mpb[2] > 0 when chr->b == 2; maybe they have other ways to solve this? or maybe they are incorrect??)

================

ALSO, may need to change copychr() too!!

ALSO, may need to do this for mpb[2] for phaseVI() too!!!

================

I think they are WRONG!! As long as the PROMETHEUS = 100 (set it smaller), the mufreq will happend to be > 1 in SiteFrequencySpectrumPrint(); because s = (int) n / 2...

THis is fine for them, but not for us. Because in phaseVI(), we want to keep a balance between #blocks = 4 and #blocks = 5, so, s = (int) n / 2 does not work